"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findPR = exports.getNewMajorVersion = exports.getNewMinorVersion = exports.getNewPatchVersion = exports.getCurrentVersion = exports.getDefaultBranch = exports.resolveConflicts = exports.closePR = exports.getChangedFilesForRebase = exports.getChangedFiles = exports.updatePr = exports.afterCreatePr = exports.isMergeable = exports.push = exports.commit = exports.abortMerge = exports.merge = exports.config = exports.getRefDiff = exports.getDiff = exports.checkBranch = exports.clone = exports.getApiHelper = void 0;
const core_1 = require("@actions/core");
const github_action_helper_1 = require("@technote-space/github-action-helper");
const misc_1 = require("./misc");
const variables_1 = require("./variables");
const { getWorkspace, useNpm, getOctokit } = github_action_helper_1.Utils;
const { getLocalRefspec, getRefspec } = github_action_helper_1.Utils;
const { getRepository, isPush } = github_action_helper_1.ContextHelper;
exports.getApiHelper = (octokit, context, logger) => new github_action_helper_1.ApiHelper(octokit, context.actionContext, logger);
exports.clone = (helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const branchName = yield variables_1.getPrBranchName(helper, octokit, context);
    logger.startProcess('Fetching...');
    helper.useOrigin(true);
    yield helper.fetchOrigin(getWorkspace(), context.actionContext, ['--no-tags'], [getRefspec(branchName)]);
    yield helper.runCommand(getWorkspace(), {
        command: 'git reset',
        args: ['--hard'],
        suppressError: true,
    });
    logger.startProcess('Switching branch to [%s]...', branchName);
    yield helper.switchBranch(getWorkspace(), branchName);
});
exports.checkBranch = (helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const clonedBranch = yield helper.getCurrentBranchName(getWorkspace());
    const branchName = yield variables_1.getPrBranchName(helper, octokit, context);
    if (branchName === clonedBranch) {
        yield helper.runCommand(getWorkspace(), {
            command: 'git merge',
            args: ['--no-edit', getLocalRefspec(branchName)],
        });
        yield helper.runCommand(getWorkspace(), 'ls -la');
        return !isPush(context.actionContext);
    }
    if (isPush(context.actionContext)) {
        throw new Error(`remote branch [${branchName}] not found.`);
    }
    logger.info('remote branch [%s] not found.', branchName);
    logger.info('now branch: %s', clonedBranch);
    const headRef = misc_1.getPrHeadRef(context);
    logger.startProcess('Cloning [%s] from the remote repo...', headRef);
    yield helper.fetchOrigin(getWorkspace(), context.actionContext, ['--no-tags'], [getRefspec(headRef)]);
    yield helper.switchBranch(getWorkspace(), headRef);
    yield helper.createBranch(getWorkspace(), branchName);
    yield helper.runCommand(getWorkspace(), 'ls -la');
    return false;
});
const getClearPackageCommands = (context) => {
    if (misc_1.isDisabledDeletePackage(context)) {
        return [];
    }
    return [
        'rm -f package.json',
        'rm -f package-lock.json',
        'rm -f yarn.lock',
    ];
};
const getGlobalInstallPackagesCommands = (context) => {
    const packages = misc_1.getActionDetail('globalInstallPackages', context, () => []);
    if (packages.length) {
        if (useNpm(getWorkspace(), core_1.getInput('PACKAGE_MANAGER'))) {
            return [
                'sudo npm install -g ' + packages.join(' '),
            ];
        }
        else {
            return [
                'sudo yarn global add ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const getDevInstallPackagesCommands = (context) => {
    const packages = misc_1.getActionDetail('devInstallPackages', context, () => []);
    if (packages.length) {
        if (useNpm(getWorkspace(), core_1.getInput('PACKAGE_MANAGER'))) {
            return [
                'npm install --save-dev ' + packages.join(' '),
            ];
        }
        else {
            return [
                'yarn add --dev ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const getInstallPackagesCommands = (context) => {
    const packages = misc_1.getActionDetail('installPackages', context, () => []);
    if (packages.length) {
        if (useNpm(getWorkspace(), core_1.getInput('PACKAGE_MANAGER'))) {
            return [
                'npm install --save ' + packages.join(' '),
            ];
        }
        else {
            return [
                'yarn add ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const getExecuteCommands = (context) => misc_1.getActionDetail('executeCommands', context, () => []);
exports.getDiff = (helper, logger) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Checking diff...');
    yield helper.runCommand(getWorkspace(), 'git add --all');
    return yield helper.getDiff(getWorkspace());
});
exports.getRefDiff = (compare, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Checking references diff...');
    yield helper.fetchBranch(getWorkspace(), compare, context.actionContext);
    return (yield helper.getRefDiff(getWorkspace(), 'HEAD', compare, misc_1.getGitFilterStatus(context), '..')).filter(line => misc_1.filterExtension(line, context));
});
const initDirectory = (helper, logger) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Initializing working directory...');
    helper.useOrigin(true);
    yield helper.runCommand(getWorkspace(), { command: 'rm', args: ['-rdf', getWorkspace()] });
});
exports.config = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () { return yield helper.config(getWorkspace(), variables_1.getCommitName(context), variables_1.getCommitEmail(context)); });
exports.merge = (branch, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Merging [%s] branch...', getLocalRefspec(branch));
    yield helper.fetchOrigin(getWorkspace(), context.actionContext, ['--no-tags'], [getRefspec(branch)]);
    yield exports.config(helper, logger, context);
    const results = yield helper.runCommand(getWorkspace(), {
        command: 'git merge',
        args: ['--no-edit', getLocalRefspec(branch)],
        suppressError: true,
    });
    return !results[0].stdout.some(RegExp.prototype.test, /^CONFLICT /);
});
exports.abortMerge = (helper, logger) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Aborting merge...');
    yield helper.runCommand(getWorkspace(), 'git merge --abort');
});
exports.commit = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield exports.config(helper, logger, context);
    logger.startProcess('Committing...');
    yield helper.makeCommit(getWorkspace(), variables_1.getCommitMessage(context));
});
exports.push = (branchName, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Pushing to %s@%s...', getRepository(context.actionContext), branchName);
    yield helper.push(getWorkspace(), branchName, context.actionContext);
});
const forcePush = (branchName, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Pushing to %s@%s...', getRepository(context.actionContext), branchName);
    yield helper.forcePush(getWorkspace(), branchName, context.actionContext);
});
exports.isMergeable = (number, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    return misc_1.getCache(misc_1.getCacheKey('pulls.get', {
        owner: context.actionContext.repo.owner,
        repo: context.actionContext.repo.repo,
        'pull_number': number,
    }), () => __awaiter(void 0, void 0, void 0, function* () {
        return (yield octokit.pulls.get({
            owner: context.actionContext.repo.owner,
            repo: context.actionContext.repo.repo,
            'pull_number': number,
        })).data.mergeable;
    }), context);
});
exports.afterCreatePr = (branchName, number, helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d;
    if ((_a = context.actionDetail.labels) === null || _a === void 0 ? void 0 : _a.length) {
        logger.info('Adding labels...');
        console.log(context.actionDetail.labels);
        yield octokit.issues.addLabels(Object.assign(Object.assign({}, context.actionContext.repo), { 'issue_number': number, labels: context.actionDetail.labels }));
    }
    if ((_b = context.actionDetail.assignees) === null || _b === void 0 ? void 0 : _b.length) {
        logger.info('Adding assignees...');
        console.log(context.actionDetail.assignees);
        yield octokit.issues.addAssignees(Object.assign(Object.assign({}, context.actionContext.repo), { 'issue_number': number, assignees: context.actionDetail.assignees }));
    }
    if (((_c = context.actionDetail.reviewers) === null || _c === void 0 ? void 0 : _c.length) || ((_d = context.actionDetail.teamReviewers) === null || _d === void 0 ? void 0 : _d.length)) {
        logger.info('Adding reviewers...');
        console.log(context.actionDetail.reviewers);
        console.log(context.actionDetail.teamReviewers);
        yield octokit.pulls.requestReviewers(Object.assign(Object.assign({}, context.actionContext.repo), { 'pull_number': number, reviewers: context.actionDetail.reviewers, 'team_reviewers': context.actionDetail.teamReviewers }));
    }
    if (misc_1.isActiveTriggerWorkflow(context)) {
        // add empty commit to trigger pr event
        yield helper.runCommand(getWorkspace(), {
            command: 'git commit',
            args: [
                '--allow-empty',
                '-qm',
                misc_1.getTriggerWorkflowMessage(context),
            ],
        });
        yield exports.push(branchName, helper, logger, context);
    }
});
exports.updatePr = (branchName, files, output, helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const apiHelper = exports.getApiHelper(getOctokit(misc_1.getApiToken()), context, logger);
    const pr = yield apiHelper.findPullRequest(branchName);
    if (pr) {
        logger.startProcess('Creating comment to PullRequest...');
        yield apiHelper.createCommentToPr(branchName, yield variables_1.getPrBody(true, files, output, helper, octokit, context));
        return exports.isMergeable(pr.number, octokit, context);
    }
    logger.startProcess('Creating PullRequest...');
    const { number } = yield apiHelper.pullsCreate(branchName, {
        title: yield variables_1.getPrTitle(helper, octokit, context),
        body: yield variables_1.getPrBody(false, files, output, helper, octokit, context),
    });
    yield exports.afterCreatePr(branchName, number, helper, logger, octokit, context);
    return true;
});
const runCommand = (command, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    if ('string' === typeof command) {
        return (yield helper.runCommand(getWorkspace(), command))[0];
    }
    const result = yield command(context, helper, logger);
    logger.displayCommand(result.command);
    if (result.stdout.length) {
        logger.displayStdout(result.stdout);
    }
    if (result.stderr.length) {
        logger.displayStderr(result.stderr);
    }
    return result;
});
const runCommands = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    const commands = [].concat.apply([], [
        getClearPackageCommands(context),
        getGlobalInstallPackagesCommands(context),
        getDevInstallPackagesCommands(context),
        getInstallPackagesCommands(context),
        getExecuteCommands(context),
    ]);
    logger.startProcess('Running commands...');
    const output = yield commands.reduce((prev, command) => __awaiter(void 0, void 0, void 0, function* () {
        const acc = yield prev;
        return acc.concat(yield runCommand(command, helper, logger, context));
    }), Promise.resolve([]));
    return {
        files: yield exports.getDiff(helper, logger),
        output,
    };
});
exports.getChangedFiles = (helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield exports.clone(helper, logger, octokit, context);
    if (yield exports.checkBranch(helper, logger, octokit, context)) {
        if (!(yield exports.merge(misc_1.getContextBranch(context), helper, logger, context))) {
            yield exports.abortMerge(helper, logger);
        }
    }
    return runCommands(helper, logger, context);
});
exports.getChangedFilesForRebase = (helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield initDirectory(helper, logger);
    const branchName = misc_1.getContextBranch(context);
    yield helper.fetchOrigin(getWorkspace(), context.actionContext, ['--no-tags'], [getRefspec(branchName)]);
    yield helper.switchBranch(getWorkspace(), branchName);
    yield helper.createBranch(getWorkspace(), yield variables_1.getPrBranchName(helper, octokit, context));
    return runCommands(helper, logger, context);
});
exports.closePR = (branchName, logger, context, message) => __awaiter(void 0, void 0, void 0, function* () { return exports.getApiHelper(getOctokit(misc_1.getApiToken()), context, logger).closePR(branchName, message !== null && message !== void 0 ? message : context.actionDetail.prCloseMessage); });
exports.resolveConflicts = (branchName, helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    if (yield exports.merge(misc_1.getContextBranch(context), helper, logger, context)) {
        // succeeded to merge
        yield exports.push(branchName, helper, logger, context);
    }
    else {
        // failed to merge
        const { files, output } = yield exports.getChangedFilesForRebase(helper, logger, octokit, context);
        if (!files.length) {
            yield exports.closePR(branchName, logger, context);
            return;
        }
        yield exports.commit(helper, logger, context);
        yield forcePush(branchName, helper, logger, context);
        yield exports.getApiHelper(getOctokit(misc_1.getApiToken()), context, logger).pullsCreateOrUpdate(branchName, {
            title: yield variables_1.getPrTitle(helper, octokit, context),
            body: yield variables_1.getPrBody(false, files, output, helper, octokit, context),
        });
    }
});
exports.getDefaultBranch = (octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    return misc_1.getCache(misc_1.getCacheKey('repos', {
        owner: context.actionContext.repo.owner,
        repo: context.actionContext.repo.repo,
    }), () => __awaiter(void 0, void 0, void 0, function* () { return yield exports.getApiHelper(octokit, context).getDefaultBranch(); }), context);
});
exports.getCurrentVersion = (octokit, context) => __awaiter(void 0, void 0, void 0, function* () { return misc_1.getCache(misc_1.getCacheKey('current-version'), () => __awaiter(void 0, void 0, void 0, function* () { return yield exports.getApiHelper(octokit, context).getLastTag(); }), context); });
exports.getNewPatchVersion = (octokit, context) => __awaiter(void 0, void 0, void 0, function* () { return misc_1.getCache(misc_1.getCacheKey('new-patch-version'), () => __awaiter(void 0, void 0, void 0, function* () { return yield exports.getApiHelper(octokit, context).getNewPatchVersion(); }), context); });
exports.getNewMinorVersion = (octokit, context) => __awaiter(void 0, void 0, void 0, function* () { return misc_1.getCache(misc_1.getCacheKey('new-minor-version'), () => __awaiter(void 0, void 0, void 0, function* () { return yield exports.getApiHelper(octokit, context).getNewMinorVersion(); }), context); });
exports.getNewMajorVersion = (octokit, context) => __awaiter(void 0, void 0, void 0, function* () { return misc_1.getCache(misc_1.getCacheKey('new-major-version'), () => __awaiter(void 0, void 0, void 0, function* () { return yield exports.getApiHelper(octokit, context).getNewMajorVersion(); }), context); });
exports.findPR = (branchName, octokit, context) => __awaiter(void 0, void 0, void 0, function* () { return misc_1.getCache(misc_1.getCacheKey('pr', { branchName }), () => __awaiter(void 0, void 0, void 0, function* () { return exports.getApiHelper(octokit, context).findPullRequest(branchName); }), context); });
